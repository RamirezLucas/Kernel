# Pebbles Kernel - Operating Systems Design and Implementation - Project 3

## 1 Features

### 1.1 ZFOD
The Pebbles Kernel does ZFOD for all frames. When a program is loaded into 
memory for the first time, it figures out the size of each region from the
elf file and allocates necessary frames at that instant. But, when a program
requests more stack_space or more user space in general through the new_pages
system call, we mark the page as requested by setting bit 9(10th bit from the 
right) of the page table entry for this address. We also set the frame address
as that of the zeroed out frame throughout the kernel which is initialized 
when the kernel boots up. The permissions for this page is set to read only
so there is no actual frame allocation until we encounter the first write 
for this address. When we receive the first write for any such requested 
memory, a page fault occurs and we check if the page had been requested 
earlier by looking at bit 9 in the page table entry and if that is the case
we allocate a new zeroed out frame and update the page table entry and 
modify the permissions to read/write.

ZFOD helps us in cases where the user allocates much more memory than he 
actually needs. In that case, we will never have to waste time allocating
and zeroing out the whole frame. We can just wait for the user to write 
to the memory to do that thereby deferring the expensive operation and 
only doing it when absolutely required. 

### 1.2 Software Exception Handler
The Pebbles kernel allows the user to install a software exception handler
where the user gets a chance to handle any exceptions as they please. The 
kernel does this by giving the user a "swexn" system call which can be 
used to register this software exception handler. During any exception,
the kernel has the responsibility of passing all the register values as
it is on the exception handler stack specified by the user at the time of
registration of the handler. The kernel makes the exception stack with the
appropriate register values in the ureg data structure for the exception
handler to use and run its logic. On a page fault, once we are sure that
the address causing the page fault isn't requested by the user on an earlier
instant, we create this exception stack for the registered handler and switch
to running that in the user space. There, the user code handles the exception
where they can reserve more frames using the syscall "new_pages" if the user
program needs it.


## 2 Syscalls

### 2.1 Fork

The fork system call copies the memory regions from the parent to the 
child task. Our kernel implementation rejects a call to fork if it is done
by a task with more than one thread running. On calling fork, the invoking
task creates a new kernel stack, pcb and tcb for the child thread and then
proceeds to copy the whole memory regions mapped to the child thread. As all
threads actually use memory above a particular threshold(USER_MEM_START) and
the memory region till that address being reserved for the kernel is directly
mapped, we do not want to waste page tables for this directly mapped address
space. As a result, we create the page tables for this memory region only once
when we are creating the first task and then on forking a new child, only the
pointers to these page tables are stored in the page directories of the child
thereby saving us space worth 4 page sizes for each new task. After copying 
the memory regions, we create a new stack for the child thread so it can start
running at the exact same point as the parent but just change the value of the
eax register which contains the return value of fork which is used to 
distinguish between a child and a parent.

A key point here is that we maintain a count of free kernel frames. Before 
copying, we ensure that there are at least the number of frames being currently
used by the parent so that we do not run out of memory later. This count 
includes the frames that have been requested but haven't been actually 
allocated along with the number of frames that the task is actually using.
If we don't have enough free frames in the system, we fail the fork system 
call.




### 2.2 Sleep

The sleep system calls deschedules the calling thread for at least n ticks,
where n is provided by the function's caller. The kernel maintains a queue of 
sleeping threads, which is examined by the timer callback function on each timer
interrupt. The key goal was to make this callback function runs as fast as
possible, avoiding linear search in the sleeping threads queue.

When a thread calls sleep(), the kernel will traverse the queue of sleeping
threads and look at how much ticks remain before the timer wakes up each thread.
The kernel will insert the invoking thread in the queue so that all threads
closer to the HEAD have less ticks to wait than it, and so that all threads
closer to the TAIl have more ticks to wait than it. Hence, at any time, the
queue contains the threads in increasing number of ticks remaining before
being woken up by the timer handler. Of course, this queue might be modifed
bu the timer callback function, so sleep() disable interrupts before traversing
the queue, seeking for the good position for the new thread. We trade this
drop in performance (linear traversal with interrupts disabled) with a really
fast timer callback function. 

The timer callback is efficient because it knows whether a thread should
be woken up by looking at only one variable, which is fast and is what happens
most of the time. When a thread should be woken up on a tick, the callback 
function needs only to look at the HEAD element in the queue of sleeping
threads as it is sorted in increasing order of remaining sleeping time.

### 2.3 Readline

The readline() system call reads the next line from the console and copies
it into a user provided buffer. When the function is called, the kernel checks 
that the buffer lies within writable user-space memory, otherwise writing to
it would cause a Page Fault. The invoking thread then has to lock a mutex before
proceeding since each thread should waits for its turn to access the input stream.
When the invoking thread is able to take the lock it fills a readline_t data
structure with information about its buffer (address and length) as well as its
TCB. The invoking thread then deschedules itself and yields to the keyboard 
consumer kernel thread. This thread reads the queue of key events and buffers
read characters until a '\n' is typed in, at which point it commits the content
of its own buffer into the user-provided buffer. Characters not consumed by this 
procedure are made available for the next call (they will be typed in the shell 
automatically during the next call to readline()). The keyboard consumer thread
then deschedules itself and yields to the thread descheduled on readline(), which
will release the lock on readline() and return from the system call.













